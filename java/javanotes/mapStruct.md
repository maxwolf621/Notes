# MapStruct

[MapStruct documentation](https://mapstruct.org/documentation/stable/reference/html/#invoking-custom-mapping-method)

- [MapStruct](#mapstruct)
  - [Annotations](#annotations)
  - [Retrieving/Calling a mapper instance](#retrievingcalling-a-mapper-instance)
  - [Mapper Dependency Injection](#mapper-dependency-injection)
    - [Injection Strategy](#injection-strategy)
  - [Basic Mapping](#basic-mapping)
    - [Mapping Fields With Different Field Names](#mapping-fields-with-different-field-names)
  - [Mapping With an Abstract Method from Abstract Class](#mapping-with-an-abstract-method-from-abstract-class)
  - [Before After Mapping](#before-after-mapping)
  - [Multiple Objects Mapping](#multiple-objects-mapping)
  - [Mappings with direct field access (public member)](#mappings-with-direct-field-access-public-member)
  - [Invoke mapping methods defined in other classes](#invoke-mapping-methods-defined-in-other-classes)
  - [Using Builders](#using-builders)
  - [Using Constructor](#using-constructor)
  - [Conversion](#conversion)
    - [numberFormat](#numberformat)
    - [dataFormat](#dataformat)
  - [Constant](#constant)
  - [Default](#default)
    - [defaultValue](#defaultvalue)
    - [Default Value Expression](#default-value-expression)
  - [expression](#expression)
  - [Mapping Collections](#mapping-collections)
    - [Map Stream](#map-stream)
  - [Enum](#enum)
  - [Conditional Mapping](#conditional-mapping)

mappers generated by MapStruct are **stateless** and **thread-safe** and thus can safely be accessed from several threads at the same time

## Annotations

- `@Mapper` : This Annotation tells the Compiler to using `org.mapstruct`
  - `use` : import self-defined mapper class
  - `componentModel` : Injection Model (e.g. cdi, spring)
- `@Mappings` : (SET of `@Mapping`)Map fields of class A and fields of class B   
    - `@Mapping`
      1. target
      2. source
      3. dateFormat：Date to String
      4. numberFormat：number to String
      5. constant
      6. expression
      7. ignore = true :ignore map this source to target
      8. qualifiedByName：map via self-defined method with `@named` annotation
      9. defaultValue
- `@MappingTarget` : a annotation of target parameter for updating the target
- `@InheritConfiguration` : inherit the Mappings Configuration method
- `@InheritInverseConfiguration` : Inverse the Mappings Configuration ( Inverse `AmapToB` method)
- `@Named` : Define the name of Class or Method to be used via qualifiedByName({name}) in `@Mappings` configuration


[Example of InheritInverseConfiguration and InheritConfiguration](https://www.cnblogs.com/DDgougou/p/13365277.html)

```java
/**
  * ComponentModel : Dependency Injection Via Spring
  */
@Mapper(componentModel = "spring")
public interface BasicObjectMapper<SOURCE, TARGET> {

    @Mappings({
        @Mapping(...),
        @Mapping(...), 
        ...})
    @InheritConfiguration
    TARGET toTarget(SOURCE sources);
 
    // It inherits the Mappings configuration 
    // from toTarget method and Inverse the configuration
    // for example ::  
    // @Mappings({@Mapping(target = "a" , source = "b")})
    // inverses to 
    // @Mappings({@Mapping(target = "b", source = "a")})
    @InheritInverseConfiguration(name = "toTarget")
    SOURCE toSource(TARGET target);

    // Inherit all mappings from a corresponding "standard" mapping method
    // Here it inherits toTarget method
    @InheritConfiguration(name = "toTarget")
    void updateTarget(SOURCE source, @MappingTarget TARGET target)

    @InheritInverseConfiguration
    List<SOURCE> from(List<TARGET> targets);
}
```

## Retrieving/Calling a mapper instance

By convention, a mapper interface should define a member called `INSTANCE` which holds a single instance of the mapper type  

The following pattern makes it very easy for clients to use mapper objects without repeatedly instantiating new instances:
```java
@Mapper
public interface AMapper {

    AMapper INSTANCE = Mappers.getMapper( AMapper.class );

    ADto mapToADto(A a);
}

@Mapper
public abstract class AMapper {

    public static final AMapper INSTANCE = Mappers.getMapper( AMapper.class );

    ADto mapToADto(A a);
}

// call a mapper 
A a = ...;
ADto dto = AMapper.INSTANCE.mapToADto(a);
```

## Mapper Dependency Injection
- [Dependency Injection](https://mapstruct.org/documentation/stable/reference/html/#using-dependency-injection)


- [Constructor or Field Injection](https://stackoverflow.com/questions/39890849/what-exactly-is-field-injection-and-how-to-avoid-it)

To use Dependency Injection 
```java
@Mapper(componentModel = "cdi")
public interface CarMapper {

    CarDto carToCarDto(Car car);
}
```

The generated mapper implementation will be marked with the `@ApplicationScoped` annotation and thus can be injected into fields, constructor arguments etc. 

using the `@Inject` annotation to process dependency injection
```java
@Inject
private CarMapper mapper;
```

### Injection Strategy

When using dependency injection, you can choose between `field` and `constructor` injection.    

This can be done by either providing the injection strategy via `@Mapper` or `@MapperConfig` annotation.
```java
@Mapper(componentModel = "cdi", 
        uses = EngineMapper.class, 
        // field or constructor injection
        injectionStrategy = InjectionStrategy.CONSTRUCTOR)
public interface CarMapper {

    CarDto carToCarDto(Car car);
}
```
The generated mapper will inject all classes defined in the uses attribute.   
- When `InjectionStrategy.CONSTRUCTOR` is used, the constructor will have the appropriate annotation and the fields won’t.   
- When `InjectionStrategy.FIELD` is used, the annotation is on the field itself. For now, the default injection strategy is field injection, but it can be configured with Configuration options. 
  > **It is recommended to use constructor injection to simplify testing.**

## Basic Mapping 

If A and B both fields have the same Field Names
```java
@Mapper 
class interface Mapper_Class_Name{
    A toA(B b)
 }
```


###  Mapping Fields With Different Field Names

If A's `field_A` and B's `field_B` both have different name but need to map together.   

For such case, we use attributes `target` and `source` of `@Mapping` annotation
```java
/* A.java */
public class A{
    private T field_A;
    //....
}

/* B.java */
public class B{
    private K field_B;
    // ...
 }

@Mapper 
class interface Mapper_Class_Name{
    // B maps to A
    @Mapping(target ="field_A", 
             source ="field_B")
    A toA(B b)
 }
 
// or using dot notation
@Mapper 
class interface Mapper_Class_Name{
    // B maps to A
    @Mapping(target ="field_A", 
             source ="b.field_B")
    A toA(B b)
 }
 
```

Declaration
```java
public static void main(String[] args)
{
  private Mapper_Class_Name mapperInstance = Mappers.getMapper(StudentMapper.class);
}
```

## Mapping With an Abstract Method from Abstract Class 

To customize our mapper in a way that exceeds `@Mapping capabilities`.

- [**Examples**](https://www.cnblogs.com/DDgougou/articles/13365290.html)

```java
@Mapper
abstract class TransactionMapper{
    
    public abstract A toA(B b){    
        A a = new A();

        // a.setter = b.getter
        a.set1(b.get1() );
        a.set2(b.get2() );

        return a;
    }
 

    // this Method will be overridden for custom mapper
    public abstract list<A> mapToA(collection<B> bs)
}
 
 
@Generated
class TransactionMapperImpl extends TransactionMapper {

    @Override
    public List<A> toA(Collection<B> bs) {
        if ( bs == null ) {
            return null;
        }

        List<A> listA = new ArrayList<>();
        
        for (B b : bs ) {
            listA.add( toA( b ) );
        }

        return listA;
    }
}
 ```

## Before After Mapping 
- [before-after Mapping](https://www.baeldung.com/mapstruct#before-after-mapping)

Another way to customize `@Mapping` capabilities by using `@BeforeMapping` and `@AfterMapping` annotations.  

The annotations are used to mark methods that are invoked right before and after the mapping logic.
 
## Multiple Objects Mapping

- [multiple objects mapping](https://mapstruct.org/documentation/stable/reference/html/#invoking-custom-mapping-method)
 
To map > 2 classes  
 
For example 
If C maps to A and B
```java 
/* A */
public class A{
  private FieldA;
  //...
}

/* B */
public class B{
  private FieldB;
  //...
}

/* C */
public class C{
  private FieldC_B;
  private FieldC_A;
  //...
}

@Mapper
class interface Mapper_Name{
  @Mapping(source = "a.FieldA", target = "FieldC_A")
  @Mapping(source = "b.FieldB", target = "FieldC_B")
  public C ToC(A a,  B b)
}
```

## Mappings with direct field access (public member)

MapStruct also supports mappings of `public` fields that have no `getters/setters`.   

MapStruct will use the fields as `read/write` accessor if it cannot find suitable `getter/setter` methods for the property.

A field is considered as a `read` accessor if it is `public` or `public final`. 
- If a field is `static` it is not considered as a read accessor.

A field is considered as a `write` accessor only if it is `public`. 
- If a field is `final` and/or `static` it is not considered as a write accessor.

```java 
public class A {

    private Long id;
    private String name;

    // getters and setter omitted for brevity ...
}

public class ADto {

    public Long id;
    public String ADtoName;
}

@Mapper
public interface Mapper {

    AMapper INSTANCE = Mappers.getMapper( AMapper.class );

    //            public member    private member
    @Mapping(source = "ADtoName", target = "name")
    A toA(ADto aDto);

    @InheritInverseConfiguration
    ADto fromA(A a);
}

/** It generates the code like this **/
public class AMapperImpl implements AMapper {

    @Override
    public A toA(ADto aDto) {
        // ...
        a.setId( aDto.id );
        a.setName( aDto.ADtoName );
        // ...
    }

    @Override
    public ADto fromA(A a) {
        // ...
        aDto.id = a.getId();
        aDto.AdtoName = a.getName();
        // ...
    }
}
```

## Invoke mapping methods defined in other classes

[Invoke mapping methods defined in other classes](https://mapstruct.org/documentation/stable/reference/html/#invoking-other-mappers)

- [Examples](https://www.cnblogs.com/DDgougou/p/13362788.html)

```java
@Named("TitleTranslator")
public class Titles {

    @Named("EnglishToGerman")
    public String translateTitleEG(String title) {
        // some mapping logic
    }

    @Named("GermanToEnglish")
    public String translateTitleGE(String title) {
        // some mapping logic
    }
}

@Mapper( uses = Titles.class )
public interface MovieMapper {

     // GermanRelease.setTitle(TitleTranslator.EnglishToGerman(movies.getTitle()))
     @Mapping( target = "title", qualifiedByName = { "TitleTranslator", "EnglishToGerman" } )
     GermanRelease toGerman( OriginalRelease movies );

}
```

```java
@Mapper
public interface MovieMapper {

     @Mapping( target = "category", qualifiedByName = "CategoryToString", defaultValue = "Unknown" )
     GermanRelease toGerman( OriginalRelease movies );

     // if Category entity in OriginalRelease is not null 
     // then use this mapper method
     @Named("CategoryToString")
     default String defaultValueForQualifier(Category cat) {
         // some mapping logic
     }

     // if Category entity in OriginalRelease is null
     // defaultValue is used 
     // pass the defaultValue to this mapper method
     @Named("CategoryToString")
     default String defaultValueForQualifier(String value) {
         return value;
     }
}
```

## Using Builders

- [Using builders](https://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders)

MapStruct also supports mapping of `immutable` types via builders.   

When performing a mapping MapStruct checks if there is a builder for the type being mapped. 

This is done via the BuilderProvider SPI.   

If a Builder exists for a certain type, then that builder will be used for the mappings.

```java
public class Person {

    private final String name;

    protected Person(Person.Builder builder) {
        this.name = builder.name;
    }

    public static Person.Builder builder() {
        return new Person.Builder();
    }

    public static class Builder {

        private String name;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Person create() {
            return new Person( this );
        }
    }
}


public interface PersonMapper {
    Person map(PersonDto dto);
}

// GENERATED CODE Loos like this 
public class PersonMapperImpl implements PersonMapper {

    public Person map(PersonDto dto) {
        if (dto == null) {
            return null;
        }

        Person.Builder builder = Person.builder();

        builder.name(dto.getName());

        return builder.create();
    }
}
```

## Using Constructor

MapStruct supports using `constructor`s for mapping target types.  

When doing a mapping MapStruct checks if there is a builder for the type being mapped. 

If there is no builder, then MapStruct looks for a single accessible constructor.

MapStruct will pick these constructors
- with `@Default`
- parameterless  Constructor 
- A single `public` Constructor
```java
public class Vehicle {

    protected Vehicle() { }

    // MapStruct will use this constructor, because it is a single public constructor
    public Vehicle(String color) { }
}

public class Car {

    // MapStruct will use this constructor, because it is a parameterless empty constructor
    public Car() { }

    public Car(String make, String color) { }
}

public class Truck {

    public Truck() { }

    // MapStruct will use this constructor, because it is annotated with @Default
    @Default
    public Truck(String make, String color) { }
}

public class Van {

    // There will be a compilation error when using this class because MapStruct cannot pick a constructor

    public Van(String make) { }

    public Van(String make, String color) { }

}
```

```java
public class Person{
    //..
    
    Public Person(String name, String surname){
        //...
    }
}

// GENERATED CODE like this
public class PersonMapperImpl implements PersonMapper {

    public Person map(PersonDto dto) {
        if (dto == null) {
            return null;
        }

        // Field of Person
        String name;
        String surname;

        name = dto.getName();
        surname = dto.getSurname();

        // use Constructor
        Person person = new Person( name, surname );

        return person;
    }
}
```

## [Conversion](https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions)

Map two different data type fields

### numberFormat
`@mapping(numberformat = "$#.00")`

for example
```java
/* A */
pubic class A{
    private double price;
    //...
}
/* B */
public class B{
    private string price;
    //..
}

/* Mapper */
@Mapper
public interface Mapper{
    @Mapping(target = "price" , source= = "price" , numberformat = "$@.00")
    B AtoB(A a);
}
```

### dataFormat

Conversion of data to `String`

```java
/* A */
public class A{
    private String Date; // String type data
    //...
}

/* B */
import java.util.GregorianCalendar;
public class B{
    private GregorianCalendar Date;
    // ... 
}

/* Mapper */
@Mapper
public interface Mapper{
    // GregorianCalendar maps to String
    @Mapping(source = "Date" , 
             target = "Date" , 
             dataFormat = "dd.MM.yyyy")
    A maptoA(B b);
}
```

 
## Constant
 
Map a constant value to target
```java
// assign MeMapTarget to ConstantMapMe
mapping(target = "ConstantMapMe" , constant = "MeMapTarget") 
```

## Default 

### defaultValue

Pass the default value in case source property is `null`  
```java
@Mapping( target = "target-property", 
          source="source-property",
          defaultValue = "default-value")
```

### Default Value Expression 

- [defaultValueExpression](https://www.baeldung.com/mapstruct#Conclusion-1)

If the source-property field of the source entity is `null`, defaultExpression will be used
```java
@Mapping(target = "target-property", 
         source="source-property" 
         defaultExpression = "java(default-value-method)")
```

For example
```java
/* A */
public class A{
    private String name;
    //..
}

/* B */
pubic class B{
    private String name;
    //..
}
/* Mapper */
public interface mapper{
    // if A.name is null 
    // defaultExpression is used
    @Mapping(target = "name" , 
             source = "name" , 
             defaultExpression = "java(UUID.randomUUID().toString())")
    B AtoB(A a);
}
```

## expression

- [expression](https://mapstruct.org/documentation/stable/reference/html/#expressions)
```java
@Mapping(target = "TargetProperty", 
   expression = "java(cLass#Method( .... ))")

// for example
@Mapper
public interface SourceTargetMapper {

    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class);

    @Mapping(target = "timeAndFormat",
             expression = "java( new org.sample.TimeAndFormat( s.getTime(), s.getFormat() ) )")
    Target sourceToTarget(Source s);

    // or with `@Mapper(imports = TimeAndFormat.class)
    @Mapping(target = "timeAndFormat",
             expression = "java( new TimeAndFormat( s.getTime(), s.getFormat() ) )")
    Target sourceToTarget(Source s);
}

```
- the fully qualified package name is specified (without `@Mapper(imports = TimeAndFormat.class)`)


## Mapping Collections 

[`@MapMapping`](https://mapstruct.org/documentation/stable/api/org/mapstruct/MapMapping.html)


- `List<ADto>` and `List<A>`
- `List<String>` and `List<Integer>`
```java
@Mapper
public interface CarMapper {

    Set<String> integerSetToStringSet(Set<Integer> integers);

    List<CarDto> carsToCarDtos(List<Car> cars);

    CarDto carToCarDto(Car car);
}

//GENERATED CODE like this
@Override
public Set<String> integerSetToStringSet(Set<Integer> integers) {
    if ( integers == null ) {
        return null;
    }

    Set<String> set = new LinkedHashSet<String>();

    for ( Integer integer : integers ) {
        set.add( String.valueOf( integer ) );
    }

    return set;
}

@Override
public List<CarDto> carsToCarDtos(List<Car> cars) {
    if ( cars == null ) {
        return null;
    }

    List<CarDto> list = new ArrayList<CarDto>();

    for ( Car car : cars ) {
        list.add( carToCarDto( car ) );
    }

    return list;
}
```

Configures the mapping between two `Map<T,K>` data types, e.g. `Map<String, String>` and `Map<Long, Date>`.
```java
@Mapper
public interface UtilityMapper {
   @MapMapping(valueDateFormat = "dd.MM.yyyy")
   Map<String, String> getMap(Map<Long, GregorianCalendar> source);
}

//GENERATED CODE
@Override
public Map<Long, Date> stringStringMapToLongDateMap(Map<String, String> source) {
    if ( source == null ) {
        return null;
    }

    Map<Long, Date> map = new LinkedHashMap<Long, Date>();

    for ( Map.Entry<String, String> entry : source.entrySet() ) {

        Long key = Long.parseLong( entry.getKey() );
        Date value;
        try {
            value = new SimpleDateFormat( "dd.MM.yyyy" ).parse( entry.getValue() );
        }
        catch( ParseException e ) {
            throw new RuntimeException( e );
        }

        map.put( key, value );
    }

    return map;
}
```

### Map Stream

```java
@Mapper
public interface UtilityMapper {
   Stream<String> getStream(Stream<Integer> source);
}

// build a stream<Integer>
Stream<Integer> numbers = Arrays.asList(1, 2, 3, 4).stream();

// Stream<integer> maps to Stream<String>
Stream<String> strings = utilityMapper.getStream(numbers);

assertEquals(4, strings.count());	

@Mapper
public interface CarMapper {

    // String and Integer 
    Set<String> integerStreamToStringSet(Stream<Integer> integers);

    // Dto and Model 
    List<CarDto> carsToCarDtos(Stream<Car> cars);

    CarDto carToCarDto(Car car);
}

//GENERATED CODE
@Override
public Set<String> integerStreamToStringSet(Stream<Integer> integers) {
    if ( integers == null ) {
        return null;
    }

    return integers.map( integer -> String.valueOf( integer ) )
        .collect( Collectors.toCollection( LinkedHashSet<String>::new ) );
}

@Override
public List<CarDto> carsToCarDtos(Stream<Car> cars) {
    if ( cars == null ) {
        return null;
    }

    return cars.map( car -> carToCarDto( car ) )
        .collect( Collectors.toCollection( ArrayList<CarDto>::new ) );
}
```

## Enum

- [Enum](https://mapstruct.org/documentation/stable/api/org/mapstruct/ValueMapping.html)

Map two Enum data types via `@ValueMapping`

```java
public enum OrderType { 
    RETAIL, 
    B2B, 
    EXTRA, 
    STANDARD, 
    NORMAL 
}
public enum ExternalOrderType { 
    RETAIL, 
    B2B, 
    SPECIAL, 
    DEFAULT 
}

// OderType maps to ExternalOrderType
public interface MAPPER{
     @ValueMapping( source = MappingConstants.NULL,
                    target = "DEFAULT" ),
     @ValueMapping( source = "STANDARD", 
                    target = MappingConstants.NULL ),
     // All rest fields in OrderType will map to 'SPECIAL' of ExternalOrderType
     @ValueMapping( source = MappingConstants.ANY_REMAINING,
                    target = "SPECIAL" )
     ExternalOrderType toExternalOrderType(OrderType orderType);
}
```

```java
 Mapping result:
 +---------------------+----------------------------+
 | OrderType           | ExternalOrderType          |
 +---------------------+----------------------------+
 | null                | ExternalOrderType.DEFAULT  |
 | OrderType.STANDARD  | null                       |
 | OrderType.RETAIL    | ExternalOrderType.RETAIL   |
 | OrderType.B2B       | ExternalOrderType.B2B      |
 | OrderType.NORMAL    | ExternalOrderType.SPECIAL  |
 | OrderType.EXTRA     | ExternalOrderType.SPECIAL  |
 +---------------------+----------------------------+
```

Source's valid value
```java
enum constant name
MappingConstants.NULL

For the rests that source's name != target's name
MappingConstants.ANY_REMAINING

FOr the rests (even source's name == target name)
MappingConstants.ANY_UNMAPPED
```

Target's valid value
```java
enum constant name
MappingConstants.NULL
```

## Conditional Mapping

Write custom condition methods that will be invoked to check if a property needs to be mapped or not.

```java
@Mapper
public class CatMapper{

    CarDto carToCarDto(Car car);


    @Condition
    default boolean isNotEmpty(String value) {
        return value != null && !value.isEmpty();
    }
}

// GENERATED CODE use the custom condition method 
// to check the property 
public class CarMapperImpl implements CarMapper {

    @Override
    public CarDto carToCarDto(Car car) {
        if ( car == null ) {
            return null;
        }

        CarDto carDto = new CarDto();

        // custom condition 
        if ( isNotEmpty( car.getOwner() ) ) {
            carDto.setOwner( car.getOwner() );
        }

        // Mapping of other properties

        return carDto;
    }
}
```